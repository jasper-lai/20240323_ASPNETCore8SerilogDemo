<body>
    <div style="font-size: medium;">
        <!-- <h2 id="如何在-aspnet-core-8-mvc-應用程式使用-serilog">如何在 ASP.NET Core 8 MVC 應用程式使用 Serilog</h2> -->
        <h2 id="how-to-use-serilog-in-aspnet-core-8-mvc-application">How to use Serilog in ASP.NET Core 8 MVC application</h2>
        <h2 id="前言">前言</h2>
        <p>筆者在前兩篇有針對 &quot;ASP.NET MVC 及 ASP.NET Core MVC 的錯誤處理&quot; 作了描述. 對於錯誤處理(Error Handling) 作了以下定義: <strong>係指錯誤取得 (Catch), 訊息規格 (Specification), 呈現 (Presentation), 及記錄 (Logging)</strong>.</p>
        <p>前兩篇涵蓋了 &quot;錯誤取得&quot; 及 &quot;訊息規格&quot;, 尚餘 &quot;呈現&quot; 及 &quot;記錄&quot;.</p>
        <h4 id="呈現-presentation">呈現 (Presentation):</h4>
        <p>需視需求而定. 由於對前端不是很專長, 這裡就先藏拙不表.</p>
        <h4 id="記錄-logging">記錄 (Logging):</h4>
        <p>本文主要著重於此. 由於很多人推薦 Serilog, 所以, 就以此作為演練的對象. 一般而言, 記錄會包含以下幾個面向:</p>
        <ul>
            <li>記錄的層級 (Log Level).<br />
                各個 Log 套件都有其 Log Level 的定義, 但大同小異.</li>
            <li>記錄的目標或提供者 (Log Target / Log Provider / Log Sinks).<br />
                例如: Console, File, MSSQL, Seq. 前3者很明確, 不作贅述. 至於 <a href="https://datalust.co/seq" target="_blank">Seq</a> 則是一個集中的 Logging 服務 , 它提供了 Web UI 介面, 可以讓<strong>開發人員</strong>或<strong>系統管理人員</strong>操作, 進行記錄的查詢.
                <ul>
                    <li>在 <a href="https://github.com/NLog/NLog.Web" target="_blank">NLog</a> 稱之為 Targets.<br />
                        對於 NLog 有興趣的朋友, 可參考這篇文章 <a href="https://blog.elmah.io/nlog-tutorial-the-essential-guide-for-logging-from-csharp/" target="_blank">NLog Tutorial - The essential guide for logging from C#</a>.</li>
                    <li>在 <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0" target="_blank">ASP.NET Core build-in Logger</a>
                        稱之為 <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0#bilp" target="_blank">Provider</a>.</li>
                    <li>在 <a href="https://github.com/serilog/serilog" target="_blank">Serilog</a>
                        稱之為 <a href="https://github.com/serilog/serilog/wiki/Provided-Sinks" target="_blank">Sinks </a>. 中文很難翻譯, 查 Google 是水槽, 反正就是一個記錄儲存的地方.</li>
                </ul>
            </li>
            <li>記錄的內容 (Log Content):
                需視需求而定.</li>
        </ul>
        <p>本文將以前述 &quot;ASP.NET Core MVC Error Handling 摘要版&quot; 的程式為基底, 繼續往下增修內容.</p>
        <p>章節內容如下:</p>
        <p>一. <a href="#section1">內建 Logger 的功能</a><br />
            二. <a href="#section2">加入 Serilog 相關套件</a><br />
            三. <a href="#section3">輸出至 Console 及 File 入門</a><br />
            四. <a href="#section4">利用 UseSerilogRequestLogging middleware 記錄 Http Request 內容</a><br />
            五. <a href="#section5">自訂輸出格式</a><br />
            六. <a href="#section6">輸出至 Seq Logging 服務入門</a><br />
            七. <a href="#section7">輸出至 MSSQL 資料庫入門</a><br />
               (一) <a href="#section7_1">套件安裝</a><br />
               (二) <a href="#section7_2">由 Serilog.Sinks.MSSqlServer 決定預設的欄位及資料型態 (by appsettings.json)</a><br />
               (三) <a href="#section7_3">Serilog.Sinks.MSSqlServer 欄位種類概述</a><br />
               (四) <a href="#section7_4">自訂 Serilog.Sinks.MSSqlServer 的欄位及資料型態 (by Program.cs)</a><br />
               (五) <a href="#section7_5">自訂 Serilog.Sinks.MSSqlServer 的欄位及資料型態 (for ProblemDetails by Program.cs)</a><br />
               (六) <a href="#section7_6">改用自定義的統一輸出格式 (MyProblemDetails)</a><br />
               (七) <a href="#section7_7">建立一層 LoggingService 打包 ILogger, 以利寫入資料庫欄位</a><br />
            八. <a href="#section8">關於 Serilog 的增強器 (Enrichers)</a></p>
        <p>
            範例存放於 GitHub, 有興趣的朋友, <a href="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo" target="_blank">可自行下載參考</a>.
        </p>
        <!--more-->
        <h2 id="一-內建-logger-的功能-">一. 內建 Logger 的功能 <a id="section1"></a></h2>
        <p>1.. 記錄的輸出目標或提供者 (Log Target or Log Provider):<br />
            預設會輸出到 Console, 但可以加入 <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0#bilp" target="_blank">其它輸出</a>, 例如: Debug / Event Log ... 等.<br />
            然而經實測, 那個 AddDebug() 似乎沒什麼作用, 按下 [F5] 進行偵錯, 發現記錄內容, 都不會輸出到 [輸出]視窗的[偵錯]項目. 但一般不會用內建的 Logger, 所以就不深究此問題了.</p>
        <pre><code class="language-csharp">#region 內建 Logger 的設置
// 不寫以下程式, 預設會輸出到 Console.
// 但修改以下的程式, 可以設定更多的輸出目標. 
builder.Logging.ClearProviders();
builder.Logging.AddConsole();
builder.Logging.AddDebug();
#endregion
</code></pre>
        <p>另外, 若有必要, 也可在 Program.cs 取得 logger 物件之後, 呼叫其方法, 輸出 log.</p>
        <pre><code class="language-csharp">#region 在 Program.cs 使用 Logger
// 建立 logger
var logger = app.Services.GetRequiredService&lt;ILogger&lt;Program&gt;&gt;();
// 使用 logger
logger.LogInformation(&quot;Application starting up at {Time}, Environment is {EnvironmentName}&quot;, DateTime.Now, app.Environment.EnvironmentName);
#endregion
</code></pre>
        <p>2.. 記錄類別 (Log Category):<br />
            簡單來說, 就是那個 ILogger<T> 那個 T 的全名, 例如: 以下程式段代表的記錄類別是 ASPNETCore8SerilogDemo.Controllers.HomeController</p>
        <pre><code class="language-csharp">private readonly ILogger&lt;HomeController&gt; _logger;
</code></pre>
        <p>3.. 記錄層級 (Log Level):</p>
        <pre><code class="language-ini">Trace = 0, Debug = 1, Information = 2, Warning = 3, Error = 4, Critical = 5, None = 6
</code></pre>
        <p>以下 appsettings.Development.json 設定檔的內容, 代表:<br />
            (1) 如果是 Microsoft.AspNetCore 的記錄類別, 會將 Warning(含) 層級以上的內容, 送至輸出目標.<br />
            (2) 其它的記輸出 Information(含) 層級以上的內容至輸出目標.</p>
        <p>註: Visual Studio 2022 預設建立的 MVC 專案, 其執行環境為 Development, 所以, 如果在 Visual Studio 2022 執行程式, 要看 appsettings.Development.json 設定檔.</p>
        <pre><code class="language-json">{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;
    }
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
</code></pre>
        <p>4.. 實測截圖如下.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/00-DefaultLoggerOutput.png?raw=true" alt="00 DefaultLoggerOutput" /></p>
        <p>5.. 小結:<br />
            以上針對 &quot;內建 Logger 的功能&quot; 作了粗淺的描述, 其實這個只適於自行演練使用, 若為實務上, 通常要寫到 File 或 DB 作為監控之用.</p>
        <h2 id="二-加入-serilog-相關套件-">二. 加入 Serilog 相關套件 <a id="section2"></a></h2>
        <p>本段會展示的輸出目標為 Console 及 File.</p>
        <p>1.. 各個 Log 套件都有其 Log Level 的定義, 但大同小異.</p>
        <pre><code class="language-ini">.NET Core 原生: Trace = 0, Debug = 1, Information = 2, Warning = 3, Error = 4, Critical = 5, None = 6
Serilog:      Verbose = 0, Debug = 1, Information = 2, Warning = 3, Error = 4, Fatal = 5
</code></pre>
        <p>2.. 加入 Serilog.AspNetCore 套件.<br />
            目前安裝的是 8.0.1 版, 它會一併安裝其它相依套件.</p>
        <pre><code class="language-bash">dotnet add package Serilog.AspNetCore
</code></pre>
        <h2 id="三-輸出至-console-及-file-入門-">三. 輸出至 Console 及 File 入門 <a id="section3"></a></h2>
        <h3 id="一-程式碼寫死">(一) 程式碼寫死:</h3>
        <p>1.. 設置 Serilog.<br />
            程式碼如下:</p>
        <pre><code class="language-csharp">using Serilog;
using Serilog.Events;

#region Serilog 的設置及使用
// 設置
Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .MinimumLevel.Override(&quot;Microsoft.AspNetCore&quot;, LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .WriteTo.File(&quot;logs/log-.txt&quot;, rollingInterval: RollingInterval.Day)
    .CreateLogger();
// 使用
builder.Host.UseSerilog();
#endregion
</code></pre>
        <p>(1) Log 是一個靜態類別, Logger 是一個靜態屬性(property), 其資料型態為 ILogger 介面.<br />
            (2) Log.Logger = new LoggerConfiguration(): 代表開始進行 Logger 的配置.<br />
            以下為 Serilog Log 類別的部份原始碼.</p>
        <pre><code class="language-csharp">public static class Log
{
    static ILogger _logger = Serilog.Core.Logger.None;
    public static ILogger Logger
    {
        get =&gt; _logger;
        set =&gt; _logger = Guard.AgainstNull(value);
    }
    // ~~~~~
}
</code></pre>
        <p>(3) .MinimumLevel.Information(): 預設最小 Log Level 為 Information. 也就是 &gt;=2 的記錄訊息都會呈現.<br />
            (4) .MinimumLevel.Override(&quot;Microsoft.AspNetCore&quot;, LogEventLevel.Warning): 覆寫 Log Category 為 Microsoft.AspNetCore 的最小 Log Level 為 Warning. 也就是 &gt;=3 的記錄訊息才會呈現.<br />
            (5) .Enrich.FromLogContext(): 用以添加 Serilog 當下的運作情境 (context).<br />
            請留意: 這個只是告知要加入 LogContext 的欄位, 但預設不會輸出, 要作以下的 {Porperties} 的設定.</p>
        <pre><code class="language-csharp">Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .WriteTo.Console(
// {Timestamp:yyyy-MM-dd HH:mm:ss.fff} formats the timestamp.
// {Level:u3} includes the log level (using 3 characters).
// {Message:l} writes the log message.
// {Properties} includes all the properties of the log event.
// {NewLine} starts a new line.
// {Exception} includes the exception details if there is any.    
        outputTemplate: &quot;{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}] {Message:l}{NewLine}{Properties}{NewLine}{Exception}&quot;
    )
    .CreateLogger();
</code></pre>
        <p>MVC 的 Controller/Action 寫入 log.</p>
        <pre><code class="language-csharp">_logger.LogInformation(&quot;這是 Enrich 首頁&quot;);
</code></pre>
        <p>預計有以下欄位.</p>
        <pre><code class="language-ini">&quot;SourceContext&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.HomeController&quot;,
&quot;ActionId&quot;: &quot;9cd447b1-f08a-4fff-b2d3-6e0234f7ba33&quot;,
&quot;ActionName&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.HomeController.Index (ASPNETCore8SerilogDemo)&quot;,
&quot;RequestId&quot;: &quot;0HN27N88VEMR7:00000001&quot;,
&quot;RequestPath&quot;: &quot;/&quot;,
&quot;ConnectionId&quot;: &quot;0HN27N88VEMR7&quot;
</code></pre>
        <p>(6) .WriteTo.Console(): 輸出至 Console.<br />
            (7) .WriteTo.File(&quot;logs/log-.txt&quot;, rollingInterval: RollingInterval.Day): 輸出至檔案 (log/log-yyyyMMdd.txt), 每天更換一個記錄檔.<br />
            (8) CreateLogger(): 依前述的配置 (LoggerConfiguration), 實際產出一個實作 ILogger 介面的靜態物件.</p>
        <p>2.. 使用 Serilog.<br />
            透過 IWebHostBuilder 加入 UseSerilog().</p>
        <pre><code class="language-csharp">builder.Host.UseSerilog();
</code></pre>
        <p>3.. 小試一下:<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/11-SerilogOutputConsoleFile_by_Code.png?raw=true" alt="11 SerilogOutputConsoleFile_by_Code" /></p>
        <h3 id="二-透過組態檔設置-appsettingsjson-or-appsettingsjson">(二) 透過組態檔設置 (appsettings.json or appsettings.*.json)</h3>
        <p>1.. 修改 appsettings.json.<br />
            以下 JSON 的設定與前述程式寫死的效果是相同的.<br />
            這裡是用以說明如果採用 JSON 設定檔, 會有那些內容.</p>
        <p>註: 請留意 appsettings.json 及 appsettings.*.json 的優先順序. 所以, 這裡直接改 appsettings.json 是改掉最基底的設定.<br />
            當然, 若要改在 appsettings.*.json 也是 OK, 只是要注意執行環境.<br />
            (1) 在 Development 的環境下, appsettings.json 會被 appsettings.Development.json 覆蓋.<br />
            (2) 在 Production 的環境下, appsettings.json 會被 appsettings.Production.json 覆蓋.</p>
        <pre><code class="language-json">{
  &quot;Serilog&quot;: {
    &quot;MinimumLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Override&quot;: {
        &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;
      }
    },
    &quot;Enrich&quot;: [ &quot;FromLogContext&quot; ],
    &quot;WriteTo&quot;: [
      { &quot;Name&quot;: &quot;Console&quot; },
      { &quot;Name&quot;: &quot;File&quot;, &quot;Args&quot;: { &quot;path&quot;:  &quot;./logs/log-.txt&quot;, &quot;rollingInterval&quot;: &quot;Day&quot; } }
    ]
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
</code></pre>
        <p>2.. 修改程式, 改為讀取 appsetting.json 及 appsettings.*.json.</p>
        <pre><code class="language-csharp">#region Serilog 的設置及使用

//// 設置: 程式寫死
//Log.Logger = new LoggerConfiguration()
//    .MinimumLevel.Information()
//    .MinimumLevel.Override(&quot;Microsoft.AspNetCore&quot;, LogEventLevel.Warning)
//    .Enrich.FromLogContext()
//    .WriteTo.Console()
//    .WriteTo.File(&quot;logs/log-.txt&quot;, rollingInterval: RollingInterval.Day)
//    .CreateLogger();

// 設置: 讀取組態檔 (appsettings.json)
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .CreateLogger();

builder.Host.UseSerilog();

#endregion
</code></pre>
        <p>3.. 小試一下:<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/12-SerilogOutputConsoleFile_by_Configpng.png?raw=true" alt="12 SerilogOutputConsoleFile_by_Configpng" /></p>
        <h2 id="四-利用-useserilogrequestlogging-middleware-記錄-http-request-內容--">四. 利用 UseSerilogRequestLogging middleware 記錄 Http Request 內容 <a id="section4"></a></h2>
        <p>如果有需要記錄所有 request / response 的一些描述資訊 (meta info) 的話 (例如: RequestMethod, RequestPath, StatusCode, Elapsed, SourceContext, ActionId, ActionName... 等) , 可以採用 UseSerilogRequestLogging 這個 middleware.</p>
        <p>1.. 使用 UseSerilogRequestLogging() middleware.<br />
            依保哥的文件所述, 這個 Request logging 的紀錄層級為 Information, 要留意. 也就是 Verbose, Debug 記錄層級的內容, 不會被寫入.</p>
        <pre><code class="language-csharp">app.UseSerilogRequestLogging();
</code></pre>
        <p>2.. 調整 appsettings.json 的內容.<br />
            針對 File 輸出的部份, 改用 Serilog.Formatting.Compact 將記錄內容, 改用 JSON 的格式.<br />
            &quot;formatter&quot;: &quot;Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact&quot;</p>
        <p>完整的 appsetting.json 如下:</p>
        <pre><code class="language-json">{
  &quot;Serilog&quot;: {
    &quot;MinimumLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Override&quot;: {
        &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;
      }
    },
    &quot;Enrich&quot;: [ &quot;FromLogContext&quot; ],
    &quot;WriteTo&quot;: [
      { &quot;Name&quot;: &quot;Console&quot; },
      {
        &quot;Name&quot;: &quot;File&quot;,
        &quot;Args&quot;: {
          &quot;path&quot;: &quot;./logs/log-.txt&quot;,
          &quot;rollingInterval&quot;: &quot;Day&quot;,
          &quot;formatter&quot;: &quot;Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact&quot;
        }
      }
    ]
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
</code></pre>
        <p>3.. 小試一下.</p>
        <p>(1) 可以看得出來, Console 比較簡要; File 的內容有點亂, 但其實每一列都代表一個 JSON 格式的記錄內容.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/21-SerilogOutputConsoleFile_UseSerilogRequestLogging_1.png?raw=true" alt="21 SerilogOutputConsoleFile_UseSerilogRequestLogging_1" /></p>
        <p>(2) 在 File 各列的 JSON, 可以看到一些以 @ 字元開頭的欄位, 說明如下.</p>
        <ul>
            <li>@t: Time stamp: 時間戳記.</li>
            <li>@mt: Message template: 訊息樣板.
                <ul>
                    <li>如下範例: @mt 就是 &quot;User {UserId} logged in at {LoginTime}&quot;, 其中 {UserId}, {LoginTime} 是一個 placeholder (中文翻譯為: 佔位符), 其內容值, 會由 userId, DateTime.Noew 取代.</li>
                    <li>這是結構化日誌記錄中的一個關鍵概念. 訊息的靜態部分和動態部分, 靜態部分保持不變, 而動態部分 (以 { } 含括的那個 placeholder, 會與變數作連結.</li>
                </ul>
            </li>
        </ul>
        <pre><code class="language-csharp">Log.Information(&quot;User {UserID} logged in at {LoginTime}&quot;, userId, DateTime.Now);
</code></pre>
        <ul>
            <li>@tr: Trace identifier: HttpContext.TraceIdentifier.</li>
            <li>@sp: Span identifier: Log Scoped Id: 可參考 <a href="https://learn.microsoft.com/zh-tw/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0&viewFallbackFrom=aspnetcore-2.2#log-scopes" target="_blank">(Microsoft Learn)Log Scopes</a>, 本文不多作說明.</li>
            <li>@l: Log Level.</li>
            <li>@x: Exception.<br />
                完整的清單, 可以參考這篇 <a href="https://github.com/serilog/serilog-expressions?tab=readme-ov-file#language-reference" target="_blank">(GitHub) Serilog Expressions / Language Reference</a></li>
        </ul>
        <p>(3) 經 <a href="https://jsongrid.com/" target="_blank">Json Grid</a> 處理後呈現, 看起來就明顯多了.</p>
        <p>(4) 以下是由 ~/Home/Index 頁面操作, 取得的 Log 內容.</p>
        <pre><code class="language-csharp">public IActionResult Index()
{
    _logger.LogInformation(&quot;ASPNETCore8SerilogDemo首頁&quot;);
    return View();
}
</code></pre>
        <pre><code class="language-json">{
    &quot;@t&quot;: &quot;2024-03-07T07:23:33.3291331Z&quot;,
    &quot;@mt&quot;: &quot;ASPNETCore8SerilogDemo首頁&quot;,
    &quot;@tr&quot;: &quot;1d220f74bb230ff942745fcf3a352bf7&quot;,
    &quot;@sp&quot;: &quot;d70f8980425a20e3&quot;,
    &quot;SourceContext&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.HomeController&quot;,
    &quot;ActionId&quot;: &quot;4ed0f57f-084f-4a2d-a98d-44c8b0d8e941&quot;,
    &quot;ActionName&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.HomeController.Index (ASPNETCore8SerilogDemo)&quot;,
    &quot;RequestId&quot;: &quot;0HN1UETUIMKQT:00000001&quot;,
    &quot;RequestPath&quot;: &quot;/&quot;,
    &quot;ConnectionId&quot;: &quot;0HN1UETUIMKQT&quot;
}
</code></pre>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/20-SerilogOutputConsoleFile_UseSerilogRequestLogging_0.png?raw=true" alt="20 SerilogOutputConsoleFile_UseSerilogRequestLogging_0" /></p>
        <p>(5) 以下是由 ~/Product/Create 頁面操作, 取得的 Log 內容.</p>
        <ul>
            <li>第10列: (發生 2XX 成功)</li>
        </ul>
        <pre><code class="language-csharp">[HttpPost]
public IActionResult CreateAjaxJsonSuccess([FromBody] ProductViewModel product)
{
    var result = $&quot;新增成功(Success) {product.Name}&quot;;
    _logger.LogInformation(&quot;處理結果: {result}&quot;, result);
    return Json(new { Result = result });
}
</code></pre>
        <pre><code class="language-json">{
    &quot;@t&quot;: &quot;2024-03-07T07:23:57.3422769Z&quot;,
    &quot;@mt&quot;: &quot;處理結果: {result}&quot;,
    &quot;@tr&quot;: &quot;60c843c9b4b8ec73b8c88da346520979&quot;,
    &quot;@sp&quot;: &quot;d7f5842d0850aafa&quot;,
    &quot;result&quot;: &quot;新增成功(Success) 費南雪&quot;,
    &quot;SourceContext&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;,
    &quot;ActionId&quot;: &quot;e386877f-9af2-4548-84c0-05c36d0e8ac9&quot;,
    &quot;ActionName&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.ProductController.CreateAjaxJsonSuccess (ASPNETCore8SerilogDemo)&quot;,
    &quot;RequestId&quot;: &quot;0HN1UETUIMKQT:0000000D&quot;,
    &quot;RequestPath&quot;: &quot;/Product/CreateAjaxJsonSuccess&quot;,
    &quot;ConnectionId&quot;: &quot;0HN1UETUIMKQT&quot;
}
</code></pre>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/22-SerilogOutputConsoleFile_UseSerilogRequestLogging_2.png?raw=true" alt="22 SerilogOutputConsoleFile_UseSerilogRequestLogging_2" /></p>
        <ul>
            <li>第12列: (發生 4XX 警告)</li>
        </ul>
        <pre><code class="language-csharp">[HttpPost]
public IActionResult OccursOutRangeException([FromBody] ProductViewModel product)
{
    var result = _service.OccursOutRangeException(product);
    return Json(new { Result = result });
}
</code></pre>
        <pre><code class="language-json">{
    &quot;@t&quot;: &quot;2024-03-07T07:24:02.1738471Z&quot;,
    &quot;@mt&quot;: &quot;Controller={controllerName} Action={actionName} =&gt; Message={message}&quot;,
    &quot;@l&quot;: &quot;Warning&quot;,
    &quot;@tr&quot;: &quot;2f62147fb52b9aead7593bc1ee4abce5&quot;,
    &quot;@sp&quot;: &quot;4dc793df4cb40a19&quot;,
    &quot;controllerName&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;,
    &quot;actionName&quot;: &quot;OccursOutRangeException&quot;,
    &quot;message&quot;: &quot;產品單價 超出範圍!&quot;,
    &quot;SourceContext&quot;: &quot;ASPNETCore8Filter.Middlewares.ExceptionHandlingMiddleware&quot;,
    &quot;RequestId&quot;: &quot;0HN1UETUIMKQT:0000000F&quot;,
    &quot;RequestPath&quot;: &quot;/Product/OccursOutRangeException&quot;,
    &quot;ConnectionId&quot;: &quot;0HN1UETUIMKQT&quot;
}
</code></pre>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/23-SerilogOutputConsoleFile_UseSerilogRequestLogging_3.png?raw=true" alt="23 SerilogOutputConsoleFile_UseSerilogRequestLogging_3" /></p>
        <ul>
            <li>第15列: (發生 5XX 錯誤)</li>
        </ul>
        <pre><code class="language-csharp">[HttpPost]
public IActionResult OccursIOException([FromBody] ProductViewModel product)
{
    throw new System.IO.IOException(&quot;費南雪武功密笈 不存在&quot;);
}
</code></pre>
        <pre><code class="language-json">{
    &quot;@t&quot;: &quot;2024-03-07T07:24:03.9677882Z&quot;,
    &quot;@mt&quot;: &quot;Controller={controllerName} Action={actionName} =&gt; Message={message}&quot;,
    &quot;@l&quot;: &quot;Error&quot;,
    &quot;@x&quot;: &quot;System.IO.IOException: 費南雪武功密笈 不存在\r\n   at ASPNETCore8SerilogDemo.Controllers.ProductController.OccursIOException(ProductViewModel product) in D:\\23-Projects.GitHub\\21-Google_Blog\\20240308_ASPNETCore8_Serilog\\ASPNETCore8SerilogDemo\\ASPNETCore8SerilogDemo\\Controllers\\ProductController.cs:line 124\r\n   at lambda_method42(Closure, Object, Object[])\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ActionMethodExecutor.SyncActionResultExecutor.Execute(ActionContext actionContext, IActionResultTypeMapper mapper, ObjectMethodExecutor executor, Object controller, Object[] arguments)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeActionMethodAsync()\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeNextActionFilterAsync()\r\n--- End of stack trace from previous location ---\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Rethrow(ActionExecutedContextSealed context)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ControllerActionInvoker.InvokeInnerFilterAsync()\r\n--- End of stack trace from previous location ---\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextResourceFilter&gt;g__Awaited|25_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, Object state, Boolean isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResourceExecutedContextSealed context)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Next(State&amp; next, Scope&amp; scope, Object&amp; state, Boolean&amp; isCompleted)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeFilterPipelineAsync()\r\n--- End of stack trace from previous location ---\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)\r\n   at Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\r\n   at ASPNETCore8Filter.Middlewares.ExceptionHandlingMiddleware.InvokeAsync(HttpContext context) in D:\\23-Projects.GitHub\\21-Google_Blog\\20240308_ASPNETCore8_Serilog\\ASPNETCore8SerilogDemo\\ASPNETCore8Filter\\Middlewares\\ExceptionHandlingMiddleware.cs:line 42&quot;,
    &quot;@tr&quot;: &quot;2c74038eb32ea071d26b0f688f0173ba&quot;,
    &quot;@sp&quot;: &quot;726294b6d80782cd&quot;,
    &quot;controllerName&quot;: &quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;,
    &quot;actionName&quot;: &quot;OccursIOException&quot;,
    &quot;message&quot;: &quot;費南雪武功密笈 不存在&quot;,
    &quot;SourceContext&quot;: &quot;ASPNETCore8Filter.Middlewares.ExceptionHandlingMiddleware&quot;,
    &quot;RequestId&quot;: &quot;0HN1UETUIMKQT:00000011&quot;,
    &quot;RequestPath&quot;: &quot;/Product/OccursIOException&quot;,
    &quot;ConnectionId&quot;: &quot;0HN1UETUIMKQT&quot;
}
</code></pre>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/24-SerilogOutputConsoleFile_UseSerilogRequestLogging_4.png?raw=true" alt="24 SerilogOutputConsoleFile_UseSerilogRequestLogging_4" /></p>
        <p>(6) UseSerilogRequestLogging middleware 會額外加上一些它自己本身的訊息輸出. 例如:</p>
        <pre><code class="language-json">{
    &quot;@t&quot;: &quot;2024-03-07T07:23:33.5531548Z&quot;,
    &quot;@mt&quot;: &quot;HTTP {RequestMethod} {RequestPath} responded {StatusCode} in {Elapsed:0.0000} ms&quot;,
    &quot;@r&quot;: [
        &quot;271.8346&quot;
    ],
    &quot;@tr&quot;: &quot;1d220f74bb230ff942745fcf3a352bf7&quot;,
    &quot;@sp&quot;: &quot;d70f8980425a20e3&quot;,
    &quot;RequestMethod&quot;: &quot;GET&quot;,
    &quot;RequestPath&quot;: &quot;/&quot;,
    &quot;StatusCode&quot;: 200,
    &quot;Elapsed&quot;: 271.8346,
    &quot;SourceContext&quot;: &quot;Serilog.AspNetCore.RequestLoggingMiddleware&quot;,
    &quot;RequestId&quot;: &quot;0HN1UETUIMKQT:00000001&quot;,
    &quot;ConnectionId&quot;: &quot;0HN1UETUIMKQT&quot;
}
</code></pre>
        <p>@r: renderings: 如果訊息樣板包含 .NET-specific 樣式 ( {Elapsed:0.0000} ), 則 @r 會是一個陣列, 逐一與訊息樣板作對應.</p>
        <p>而在 Console 就只會出現以下的內容.</p>
        <pre><code class="language-ini">[15:23:33 INF] HTTP GET / responded 200 in 271.8346 ms
</code></pre>
        <p>4.. 小結:<br />
            除了應用程式輸出的 Log 之外, UseSerilogRequestLogging middleware 也會補上自己產出的訊息.</p>
        <h2 id="五-自訂輸出格式-">五. 自訂輸出格式 <a id="section5"></a></h2>
        <p>由於預設的輸出格式, 可能不符需求, 需要自訂. 可以參考 <a href="https://github.com/serilog/serilog/wiki/Formatting-Output" target="_blank">(GitHub) Formatting Output</a> 的說明. 該文亦有針對 JSON 作一些格式化的說明.</p>
        <ul>
            <li>Exception: 完整的例外訊息. 若沒例外物件的話, 會是 Empty.</li>
            <li>Level: Log Level, 預設為完整的 Log Level 名稱. 可以加一些修飾, 成為 3 個字元, 例如: {Level:u3} 全大寫, {Level:w3} 全小寫.</li>
            <li>Message: Log Message, 預設為純文字. 可以加一些修飾, 例如: {Message:l}-移除單引號或雙引號 {Message:j}-採用 json 格式輸出.</li>
            <li>NewLine: 即 System.Environment.NewLine.</li>
            <li>Properties: 輸出中其他未出現的所有事件屬性值. 使用 {Properties:j} 代表輸出為 json 格式.</li>
            <li>Timestamp: 事件的時間戳記, 為 DateTimeOffset.</li>
            <li>TraceId: HttpContext.TradeIdentity.</li>
            <li>SpanId: Scoped Id.</li>
        </ul>
        <p>以下僅就 Console 的輸出, 作了一個.</p>
        <ul>
            <li>{Message} 的效果</li>
        </ul>
        <pre><code class="language-ini">2024-03-08 11:52:58.787 [INF] Application starting up at 03/08/2024 11:52:58, Environment is &quot;Development&quot;
2024-03-08 11:52:59.091 [INF] Now listening on: &quot;https://localhost:7020&quot;
2024-03-08 11:52:59.095 [INF] Now listening on: &quot;http://localhost:5189&quot;
2024-03-08 11:52:59.117 [INF] Application started. Press Ctrl+C to shut down.
2024-03-08 11:52:59.119 [INF] Hosting environment: &quot;Development&quot;
2024-03-08 11:52:59.122 [INF] Content root path: &quot;D:\\23-Projects.GitHub\\21-Google_Blog\\20240308_ASPNETCore8_Serilog\\ASPNETCore8SerilogDemo\\ASPNETCore8SerilogDemo&quot;
2024-03-08 11:52:59.632 [INF] HTTP &quot;GET&quot; &quot;/Product/Create&quot; responded 200 in 132.1355 ms
2024-03-08 11:53:03.237 [INF] ASPNETCore8Filter首頁
2024-03-08 11:53:03.249 [INF] HTTP &quot;GET&quot; &quot;/ASPNETCore8Filter/Home/Index&quot; responded 200 in 14.2502 ms
2024-03-08 11:53:04.958 [INF] HTTP &quot;GET&quot; &quot;/Product/Create&quot; responded 200 in 12.8478 ms
2024-03-08 11:53:07.295 [WRN] Controller=&quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot; Action=&quot;OccursDataNotExistException&quot; =&gt; Message=&quot;費南雪 資料不存在!&quot;
2024-03-08 11:53:07.299 [INF] &quot;{\&quot;Title\&quot;:\&quot;NotFound\&quot;,\&quot;Status\&quot;:404,\&quot;Detail\&quot;:\&quot;費南雪 資料不存在!\&quot;,\&quot;Instance\&quot;:\&quot;/Product/OccursDataNotExistException\&quot;,\&quot;TraceId\&quot;:\&quot;70e87fbe-ba37-40f0-9e8a-58e8f4f8d6e2\&quot;,\&quot;ControllerName\&quot;:\&quot;ASPNETCore8SerilogDemo.Controllers.ProductController\&quot;,\&quot;ActionName\&quot;:\&quot;OccursDataNotExistException\&quot;}&quot;
2024-03-08 11:53:07.304 [INF] HTTP &quot;POST&quot; &quot;/Product/OccursDataNotExistException&quot; responded 404 in 45.5716 ms
</code></pre>
        <ul>
            <li>{Message:l} 的效果: 把多餘的雙引號移掉, 看來似乎有比較清爽.</li>
        </ul>
        <pre><code class="language-ini">2024-03-08 11:53:48.174 [INF] Application starting up at 03/08/2024 11:53:48, Environment is Development
2024-03-08 11:53:48.498 [INF] Now listening on: https://localhost:7020
2024-03-08 11:53:48.501 [INF] Now listening on: http://localhost:5189
2024-03-08 11:53:48.524 [INF] Application started. Press Ctrl+C to shut down.
2024-03-08 11:53:48.526 [INF] Hosting environment: Development
2024-03-08 11:53:48.528 [INF] Content root path: D:\23-Projects.GitHub\21-Google_Blog\20240308_ASPNETCore8_Serilog\ASPNETCore8SerilogDemo\ASPNETCore8SerilogDemo
2024-03-08 11:53:49.067 [INF] HTTP GET /Product/Create responded 200 in 149.6317 ms
2024-03-08 11:53:56.832 [INF] ASPNETCore8Filter首頁
2024-03-08 11:53:56.843 [INF] HTTP GET /ASPNETCore8Filter/Home/Index responded 200 in 13.8720 ms
2024-03-08 11:53:58.028 [INF] HTTP GET /Product/Create responded 200 in 5.5163 ms
2024-03-08 11:54:07.017 [WRN] Controller=ASPNETCore8SerilogDemo.Controllers.ProductController Action=OccursDataNotExistException =&gt; Message=費南雪 資料不存在!
2024-03-08 11:54:07.021 [INF] {&quot;Title&quot;:&quot;NotFound&quot;,&quot;Status&quot;:404,&quot;Detail&quot;:&quot;費南雪 資料不存在!&quot;,&quot;Instance&quot;:&quot;/Product/OccursDataNotExistException&quot;,&quot;TraceId&quot;:&quot;4d279475-a886-4e3d-b3b4-f8073aa3274d&quot;,&quot;ControllerName&quot;:&quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;,&quot;ActionName&quot;:&quot;OccursDataNotExistException&quot;}
2024-03-08 11:54:07.022 [INF] HTTP POST /Product/OccursDataNotExistException responded 404 in 35.1407 ms
</code></pre>
        <h2 id="六-輸出至-seq-logging-服務入門-">六. 輸出至 Seq Logging 服務入門 <a id="section6"></a></h2>
        <p>Seq 是一個集中的 Logging 服務 , 它提供了 Web UI 介面, 可以讓<strong>開發人員</strong>或<strong>系統管理人員</strong>操作, 進行記錄的查詢. <strong>請留意, 這個不適合開放給使用者查詢!</strong></p>
        <p>Seq 提供了 2 種執行方式: (1) <a href="https://docs.datalust.co/docs/getting-started" target="_blank">自行在 Windows Server 安裝</a>, (2) <a href="https://docs.datalust.co/docs/getting-started-with-docker" target="_blank">下載並執行基於 Linux 的 docker image</a>. 本文採用 docker 的方式執行.</p>
        <p>1.. 修改程式: 加入對 Seq 的輸出.<br />
            (1) nuget Serilog.Sinks.Seq (目前為 7.0.0 版).<br />
            (2) 調整 Program.cs.<br />
            加入 .WriteTo.Seq(&quot;http://localhost:5341&quot;) 程式段.</p>
        <pre><code class="language-csharp">// 設置: 讀取組態檔 (appsettings.json)
Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;)
    .CreateLogger();

builder.Host.UseSerilog();
</code></pre>
        <p>註: <strong>在 nuget manager 出現了 &quot;您安裝了 3 個有弱點的套件&quot; 的訊息, 經查, 都是 Nuget 6.3.1, 所以, 改升級至 6.8.1.</strong> 不然, 看到那些警告, 就很討厭.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/31-NugetManager_%E6%9C%89%E5%BC%B1%E9%BB%9E%E7%9A%84%E5%A5%97%E4%BB%B6.png?raw=true" alt="31 NugetManager_有弱點的套件" /></p>
        <p>(3) 調整 ExceptionHandlingMiddleware.cs.<br />
            加入輸出結構化資料的 LogRequest() 程式段, <strong>重要: Seq Logging Service UI 可以支援 結構化資料 的查詢.</strong></p>
        <pre><code class="language-csharp">public async Task InvokeAsync(HttpContext context)
{
    try
    {
        LogRequest(context);
        await _next(context);
    }
    catch (Exception ex)
    {
        await HandleExceptionAsync(context, ex);
    }
}
</code></pre>
        <pre><code class="language-csharp">private void LogRequest(HttpContext context)
{
    // STEP 1: 取得 trace id / controller name / action name
    var traceId = context.TraceIdentifier;
    string? controllerName = null;
    string? actionName = null;

    var endpoint = context.GetEndpoint();
    if (endpoint != null)
    {
        var actionDescriptor = endpoint.Metadata.GetMetadata&lt;ControllerActionDescriptor&gt;();
        if (actionDescriptor != null)
        {
            controllerName = actionDescriptor.ControllerTypeInfo.FullName;
            actionName = actionDescriptor.ActionName;
        }
    }

    // 結構化輸出 
    _logger.LogInformation(&quot;TraceId={TraceId}, ControllerName={ControllerName}, ActionName={ActionName}&quot;,
        traceId, controllerName, actionName);
}
</code></pre>
        <p>2.. 執行 docker desktop for windows.</p>
        <p>3.. 執行 docker 指令, 以運行 Seq Logging Service.</p>
        <pre><code class="language-bash">docker run --name seq -d --restart unless-stopped -e ACCEPT_EULA=Y -p 5341:80 datalust/seq:latest
</code></pre>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/32-SerilogOutputSeq_1.png?raw=true" alt="32 SerilogOutputSeq_1" /></p>
        <p>4.. 打開 Chrome / Edge ... 等瀏覽器, 輸入 http://localhost:5341<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/33-SerilogOutputSeq_2_init_no_events.png?raw=true" alt="33 SerilogOutputSeq_2_init_no_events" /></p>
        <p>5.. 執行 ASPNETCore8SerilogDemo 程式. 會發現 Console 有記錄輸出, 但 Seq 似乎沒有動靜. 此時, 請按下 [Go], 如圖.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/34-SerilogOutputSeq_3_go.png?raw=true" alt="34 SerilogOutputSeq_3_go" /></p>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/35-SerilogOutputSeq_4_%E6%9C%89%E8%B3%87%E6%96%99%E4%BA%86.png?raw=true" alt="35 SerilogOutputSeq_4_有資料了" /><br />
            上圖的黃框, 其實是一些 Properties, 其中 TraceId, ControllerName, ActionName 就是前述樣版格式化輸出的欄位. 這個有什麼用呢? Seq 有一個很強的功能, 可以將所有的 Log 資料, 以 樣版格式化輸出的欄位, 作為查詢的條件. 例如:</p>
        <ul>
            <li>ControllerName=&quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;</li>
            <li>ControllerName like &quot;%.Product%&quot;</li>
        </ul>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/36-SerilogOutputSeq_5_query_syntax.png?raw=true" alt="36 SerilogOutputSeq_5_query_syntax" /></p>
        <p>詳細的 Seq 查詢語法, 可參考 <a href="https://docs.datalust.co/docs/query-syntax" target="_blank">Seq 官方文件的 Search Expression Syntax</a></p>
        <p>6.. 如果 Log 資料太多, 可以刪掉.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/41-SeqRemoveEvents_1.png?raw=true" alt="41 SeqRemoveEvents_1" /><br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/42-SeqRemoveEvents_2_%E5%85%A8%E6%B8%85.png?raw=true" alt="42 SeqRemoveEvents_2_全清" /></p>
        <p><strong>7.. 使用 Serilog 訊息樣板提供的物件解構子 功能</strong></p>
        <p>Seq 提供物件解構子的功能, 在訊息樣板採用 {@placeHolder}, 即可將對應的物件, 轉成多個 placeHolder.</p>
        <p>(1) 官網的入門範例.<br />
            關於 placeHolder 的說明, 可以 <a href="https://github.com/serilog/serilog" target="_blank">參考這篇的例子</a>. 有 @ 前置的話, 會將傳入的物作序列化; 沒有 @ 前置的話, 就直接採用 ToString().</p>
        <pre><code class="language-csharp">var position = new { Latitude = 25, Longitude = 134 };
var elapsedMs = 34;

log.Information(&quot;Processed {@Position} in {Elapsed} ms&quot;, position, elapsedMs);
</code></pre>
        <p>(2) 修改 ExceptionHandlingMiddleware.cs<br />
            重點在以下 2 個程式段:</p>
        <ul>
            <li>_logger.LogWarning(&quot;警告 {@result}&quot;, result);</li>
            <li>_logger.LogError(exception, &quot;錯誤: {@result}&quot;, result);</li>
        </ul>
        <p>{@result}, result 會被展開為:</p>
        <ul>
            <li>&quot;{result.Status} {result.Ttile} {result.Detail} ... {result.TraceId}&quot;, result.Status, result.Title, result.Detail, ... result.TraceId</li>
        </ul>
        <p>請留意:
            <strong>以下是把 response變數(ProblemDetails物件), 重整為 &quot;匿名物件&quot; (anynymous) 後作輸出; 與後續提到的直接輸出 response變數內容, 有一些差異.</strong></p>
        <pre><code class="language-csharp">#region 原始的作法
//string jsonString = JsonSerializer.Serialize(response, _jsonOptions);
//if (response.Status &gt;= 400 &amp;&amp; response.Status &lt; 500)
//    _logger.LogWarning(&quot;Controller={controllerName} Action={actionName} =&gt; Message={message}&quot;, controllerName, actionName, exception.Message);
//if (response.Status &gt;= 500)
//    _logger.LogError(exception, &quot;Controller={controllerName} Action={actionName} =&gt; Message={message}&quot;, controllerName, actionName, exception.Message);
//_logger.LogInformation(&quot;{json}&quot;, jsonString);    //輸出完整的 json 字串
#endregion

#region 針對 Serilog 作結構化輸出 (@解構子)
var result = new
{
    Status = response.Status,
    Title = response.Title,
    Detail = response.Detail,
    Instance = response.Instance,
    ControllerName = controllerName,
    ActionName = actionName,
    TraceId = traceId
};
#endregion

if (response.Status &gt;= 400 &amp;&amp; response.Status &lt; 500)
    _logger.LogWarning(&quot;警告 {@result}&quot;, result);
if (response.Status &gt;= 500)
    _logger.LogError(exception, &quot;錯誤: {@result}&quot;, result);
</code></pre>
        <p>(3) 看一下 Console 的輸出結果.<br />
            第1個黃框對應的是: _logger.LogWarning(&quot;警告 {@result}&quot;, result);<br />
            第2個黃框及第1個紅框對應的是: _logger.LogError(exception, &quot;錯誤: {@result}&quot;, result);<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/46-SerilogDestructor_Console.png?raw=true" alt="46 SerilogDestructor_Console" /></p>
        <p>(4) 看一下 Seq 的輸出結果.<br />
            下圖是 _logger.LogWarning(&quot;警告 {@result}&quot;, result); 的結果.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/47-SerilogDestructor_Seq_Warning.png?raw=true" alt="47 SerilogDestructor_Seq_Warning" /></p>
        <p>下圖是 _logger.LogError(exception, &quot;錯誤: {@result}&quot;, result); 的結果.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/48-SerilogDestructor_Seq_Error.png?raw=true" alt="48 SerilogDestructor_Seq_Error" /></p>
        <p>(5) 如果直接把 response 物件 (其型別為 ProblemDetails) 輸出至 Log 的話, 會變成這個狀況.</p>
        <p>程式碼:</p>
        <pre><code class="language-csharp">if (response.Status &gt;= 400 &amp;&amp; response.Status &lt; 500)
    _logger.LogWarning(&quot;警告 {@result}&quot;, response);
if (response.Status &gt;= 500)
    _logger.LogError(exception, &quot;錯誤: {@result}&quot;, response);
</code></pre>
        <p>執行結果:</p>
        <ul>
            <li>Console:<br />
                <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/49-1-SerilogDestructor_Console.png?raw=true" alt="49 1 SerilogDestructor_Console" /></li>
            <li>Seq:<br />
                <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/49-2-SerilogDestructor_Seq.png?raw=true" alt="49 2 SerilogDestructor_Seq" /></li>
        </ul>
        <h2 id="七-輸出至-mssql-資料庫入門-">七. 輸出至 MSSQL 資料庫入門 <a id="section7"></a></h2>
        <p>其實最常見的需求是將 Log 輸出至資料庫, 然後再撰寫查詢程式, 供查詢之用.<br />
            以下將以寫入至 MSSQL 作說明.</p>
        <h3 id="一-套件安裝-">(一) 套件安裝 <a id="section7_1"></a></h3>
        <p>安裝 <a href="https://www.nuget.org/packages/serilog.sinks.mssqlserver" target="_blank">Serilog.Sinks.MSSqlServer</a> 套件.</p>
        <h3 id="二-由-serilogsinksmssqlserver-決定預設的欄位及資料型態-by-appsettingsjson-">(二) 由 Serilog.Sinks.MSSqlServer 決定預設的欄位及資料型態 (by appsettings.json) <a id="section7_2"></a></h3>
        <p>修改 appsettings.json, 加入輸出至 MSSQL 的設置.</p>
        <p>參考 <a href="https://github.com/serilog-mssql/serilog-sinks-mssqlserver#columnoptions-object" target="_blank">(GitHub) serilog-sinks-mssqlserver 的 README.md </a> 的說明.</p>
        <p>不論是用程式或 appsettings.json 作設置, 會包含以下參數. 其中, 最重要的是以下 3 個.</p>
        <ul>
            <li>connectionString: 資料庫的連接字串.</li>
            <li>sinkOptions: Log Table 名稱及是否自動建立.</li>
            <li>columnOptions: Log Table 的欄位定義.</li>
        </ul>
        <pre><code class="language-csharp">{
  &quot;Name&quot;: &quot;MSSqlServer&quot;,
  &quot;Args&quot;: {
    &quot;connectionString&quot;: &quot;Server=.\\SQL2016;Database=Cookies;Persist Security Info=False;Trusted_Connection=True;Encrypt=True;TrustServerCertificate=True;&quot;,
    &quot;schemaName&quot;: &quot;dbo&quot;,
    &quot;tableName&quot;: &quot;Logs&quot;,
    &quot;autoCreateSqlTable&quot;: true
  }
}
</code></pre>
        <p>如果只作以上設定的話, 會建立一個名稱為 Logs 的 Table, 包含以下欄位.</p>
        <pre><code class="language-sql">CREATE TABLE [dbo].[Logs] (
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [Message] [nvarchar](max) NULL,
    [MessageTemplate] [nvarchar](max) NULL,
    [Level] [nvarchar](max) NULL,
    [TimeStamp] [datetime] NULL,
    [Exception] [nvarchar](max) NULL,
    [Properties] [nvarchar](max) NULL,
    CONSTRAINT [PK_Logs] PRIMARY KEY CLUSTERED ( [Id] ASC )
);
GO
</code></pre>
        <p>小試一下:<br />
            (1) table:Logs 會自動被建立.<br />
            (2) 相關的資料會寫寫到 table:Logs.<br />
            (3) Properties 欄位內容是 Xml 的格式.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/61-SerilogOutput_Mssql.png?raw=true" alt="61 SerilogOutput_Mssql" /></p>
        <pre><code class="language-xml">&lt;properties&gt;
    &lt;property key='SourceContext'&gt;ASPNETCore8SerilogDemo.Controllers.HomeController&lt;/property&gt;
    &lt;property key='ActionId'&gt;3e479b65-ecf8-49fa-91c4-ed69dbdf02ee&lt;/property&gt;
    &lt;property key='ActionName'&gt;ASPNETCore8SerilogDemo.Controllers.HomeController.Index (ASPNETCore8SerilogDemo)&lt;/property&gt;
    &lt;property key='RequestId'&gt;0HN23Q28LEMFK:00000001&lt;/property&gt;
    &lt;property key='RequestPath'&gt;/&lt;/property&gt;
    &lt;property key='ConnectionId'&gt;0HN23Q28LEMFK&lt;/property&gt;
&lt;/properties&gt;
</code></pre>
        <h3 id="三-serilogsinksmssqlserver-欄位種類概述-">(三) Serilog.Sinks.MSSqlServer 欄位種類概述 <a id="section7_3"></a></h3>
        <p>1.. 標準欄位: (也就是前述 table:Logs)</p>
        <p>以下是為了寫到資料庫用的.</p>
        <ul>
            <li>Id // The optional primary key</li>
            <li>Message // The message rendered with the template given the properties associated with the event</li>
            <li>MessageTemplate // The message template describing the event.</li>
            <li>Level // The level of the event.</li>
            <li>TimeStamp // The time at which the event occurred.</li>
            <li>Exception // An exception associated with the event, or null.</li>
            <li>Properties // Properties associated with the event, including those presented in Serilog.Sinks.MSSqlServer.StandardColumn.MessageTemplate.</li>
        </ul>
        <p>以下是為了相容於舊版用的 (backwards-compatibility).</p>
        <ul>
            <li>TraceId // The OpenTelemetry trace id of the event.</li>
            <li>SpanId // The OpenTelemetry span id of the event.</li>
            <li>LogEvent // A log event.</li>
        </ul>
        <p>如果要存入資料庫的話, 可以這樣作.</p>
        <pre><code class="language-csharp">// we don't need XML data
columnOptions.Store.Remove(StandardColumn.Properties);

// we do want JSON data and OpenTelemetry
columnOptions.Store.Add(StandardColumn.LogEvent);
columnOptions.Store.Add(StandardColumn.TraceId);
columnOptions.Store.Add(StandardColumn.SpanId);
</code></pre>
        <p>2.. 額外欄位: (AdditionalColumns)<br />
            因應需求, 而額外添加的欄位.</p>
        <pre><code class="language-csharp">var columnOptions = new ColumnOptions
{
    AdditionalColumns = new Collection&lt;SqlColumn&gt;
    {
        new SqlColumn
            {ColumnName = &quot;EnvironmentUserName&quot;, PropertyName = &quot;UserName&quot;, DataType = SqlDbType.NVarChar, DataLength = 64},

        new SqlColumn
            {ColumnName = &quot;UserId&quot;, DataType = SqlDbType.BigInt, NonClusteredIndex = true},

        new SqlColumn
            {ColumnName = &quot;RequestUri&quot;, DataType = SqlDbType.NVarChar, DataLength = -1, AllowNull = false},
    }
};
</code></pre>
        <h3 id="四-自訂-serilogsinksmssqlserver-的欄位及資料型態-by-programcs-">(四) 自訂 Serilog.Sinks.MSSqlServer 的欄位及資料型態 (by Program.cs) <a id="section7_4"></a></h3>
        <p>如果想要移掉一些預設的欄位, 或者調整欄位長度, 要怎麼作呢?<br />
            由於用 appsettings.json 並不是那麼明顯, 改用 Program.cs 客製可能會比較容易撰寫.</p>
        <p>1.. 修改 appsettings.json 的設定:</p>
        <pre><code class="language-json">{
  &quot;ConnectionStrings&quot;: {
    // Serilog.Sinks.MSSqlServer 連接字串 
    &quot;SerilogConnectionString&quot;: &quot;Server=.\\SQL2016;Database=Cookies;Persist Security Info=False;Trusted_Connection=True;Encrypt=True;TrustServerCertificate=True;&quot;
  },
  &quot;Serilog&quot;: {
    &quot;MinimumLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Override&quot;: {
        &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot;
      }
    },
    &quot;Enrich&quot;: [ &quot;FromLogContext&quot; ],
    &quot;WriteTo&quot;: [
      {
        &quot;Name&quot;: &quot;Console&quot;,
        &quot;Args&quot;: {
          &quot;outputTemplate&quot;: &quot;{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}] {Message:l}{NewLine}{Exception}&quot;
        }
      },
      {
        &quot;Name&quot;: &quot;File&quot;,
        &quot;Args&quot;: {
          &quot;path&quot;: &quot;./logs/log-.txt&quot;,
          &quot;rollingInterval&quot;: &quot;Day&quot;,
          &quot;formatter&quot;: &quot;Serilog.Formatting.Compact.CompactJsonFormatter, Serilog.Formatting.Compact&quot;
        }
      }
      // 以下是原本寫在 appsettings.json 的 Serilog.Sinks.MSSqlServer 設定 
      //,
      //{
      //  &quot;Name&quot;: &quot;MSSqlServer&quot;,
      //  &quot;Args&quot;: {
      //    &quot;connectionString&quot;: &quot;Server=.\\SQL2016;Database=Cookies;Persist Security Info=False;Trusted_Connection=True;Encrypt=True;TrustServerCertificate=True;&quot;,
      //    &quot;schemaName&quot;: &quot;dbo&quot;,
      //    &quot;tableName&quot;: &quot;Logs&quot;,
      //    &quot;autoCreateSqlTable&quot;: true
      //  }
      //}
    ]
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
</code></pre>
        <p>2.. 修改 Program.cs:</p>
        <pre><code class="language-csharp">#region 取得連接字串
var configuration = builder.Configuration;
var serilogConnectionString = configuration[&quot;ConnectionStrings:SerilogConnectionString&quot;]?.ToString() ?? string.Empty;
#endregion
</code></pre>
        <pre><code class="language-csharp">#region Serilog 的設置及使用
// ### for Seq + MSSQL (by hard coding)
// 目標:
// (1) 保留 Properties 的 SourceContext 欄位
// (2) 移除 MessageTemplate, Properties 這 2 個標準欄位

// (1) 保留 Properties 的 SourceContext 欄位
var columnOptions = new ColumnOptions
{
    AdditionalColumns = new Collection&lt;SqlColumn&gt;
    {
        new() {
            ColumnName = &quot;SourceContext&quot;,
            DataType = SqlDbType.NVarChar,
            DataLength = 512,
            AllowNull = true,
            PropertyName = &quot;SourceContext&quot;, // Match the property key in the log event
            NonClusteredIndex = true
        }
    }
};

// (2) 移除 MessageTemplate, Properties 這 2 個標準欄位
columnOptions.Store.Remove(StandardColumn.Properties);
columnOptions.Store.Remove(StandardColumn.MessageTemplate);

Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;)
    .WriteTo.MSSqlServer(
        connectionString: serilogConnectionString,
        sinkOptions: new MSSqlServerSinkOptions
        {
            AutoCreateSqlTable = true,
            SchemaName = &quot;dbo&quot;,
            TableName = &quot;Logs&quot;
        },
        columnOptions: columnOptions
    )
    .CreateLogger();

builder.Host.UseSerilog();

#endregion
</code></pre>
        <p>3.. 小試一下:</p>
        <p>(1) 建立的 table 欄位</p>
        <pre><code class="language-sql">CREATE TABLE [dbo].[Logs] (
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [Message] [nvarchar](max) NULL,
    [Level] [nvarchar](max) NULL,
    [TimeStamp] [datetime] NULL,
    [Exception] [nvarchar](max) NULL,
    [SourceContext] [nvarchar](512) NULL,
    CONSTRAINT [PK_Logs] PRIMARY KEY CLUSTERED ( [Id] ASC )
);
GO
</code></pre>
        <p>(2) 執行結果:<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/62-SerilogOutput_Mssql_hardcode_01.png?raw=true" alt="62 SerilogOutput_Mssql_hardcode_01" /></p>
        <h3 id="五-自訂-serilogsinksmssqlserver-的欄位及資料型態-for-problemdetails-by-programcs-">(五) 自訂 Serilog.Sinks.MSSqlServer 的欄位及資料型態 (for ProblemDetails by Program.cs) <a id="section7_5"></a></h3>
        <p>1.. 修改 Program.cs:</p>
        <p><strong>將資料庫欄位對應至 Model Property.</strong><br />
            <strong>請注意: 如果是用解構子的話, 必須在對應的 Model Property, 加上 {@placeHolder} 那個 placeHolder 作為前綴.</strong></p>
        <pre><code class="language-csharp">// ### for Seq + MSSQL (by hard coding)
// 目標:
// (1) 保留 Properties 的 SourceContext 欄位
// (2) 移除 MessageTemplate 這個標準欄位
// (3) 加入 ProblemDetails 的相關欄位  

// (1) 保留 Properties 的 SourceContext 欄位
// (3) 加入 ProblemDetails 的相關欄位
var columnOptions = new ColumnOptions
{
    AdditionalColumns = new Collection&lt;SqlColumn&gt;
    {
        new() { ColumnName = &quot;SourceContext&quot;, DataType = SqlDbType.NVarChar, DataLength = 512, AllowNull = true, PropertyName = &quot;SourceContext&quot; },
        new() { ColumnName = &quot;Title&quot;, DataType = SqlDbType.NVarChar, DataLength = 50, AllowNull = true, PropertyName = &quot;result.Title&quot; },
        new() { ColumnName = &quot;Status&quot;, DataType = SqlDbType.Int, AllowNull = true, PropertyName = &quot;result.Status&quot; },
        new() { ColumnName = &quot;Detail&quot;, DataType = SqlDbType.NVarChar, DataLength = 512, AllowNull = true, PropertyName = &quot;result.Detail&quot; },
        new() { ColumnName = &quot;Instance&quot;, DataType = SqlDbType.NVarChar, DataLength = 512, AllowNull = true, PropertyName = &quot;result.Instance&quot; },
        new() { ColumnName = &quot;TraceId&quot;, DataType = SqlDbType.NVarChar, DataLength = 128, AllowNull = true, PropertyName = &quot;result.TraceId&quot; },
        new() { ColumnName = &quot;ControllerName&quot;, DataType = SqlDbType.NVarChar, DataLength = 256, AllowNull = true, PropertyName = &quot;result.ControllerName&quot; },
        new() { ColumnName = &quot;ActionName&quot;, DataType = SqlDbType.NVarChar, DataLength = 256, AllowNull = true, PropertyName = &quot;result.ActionName&quot; }
        //new() { ColumnName = &quot;Exception&quot;, DataType = SqlDbType.NVarChar, DataLength = -1, AllowNull = true } // -1 for max
    }
};

// (2) 移除 MessageTemplate 這個標準欄位
//columnOptions.Store.Remove(StandardColumn.Properties);
columnOptions.Store.Remove(StandardColumn.MessageTemplate);

Log.Logger = new LoggerConfiguration()
    .ReadFrom.Configuration(builder.Configuration)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;)
    .WriteTo.MSSqlServer(
        connectionString: serilogConnectionString,
        sinkOptions: new MSSqlServerSinkOptions
        {
            AutoCreateSqlTable = true,
            SchemaName = &quot;dbo&quot;,
            TableName = &quot;Logs&quot;
        },
        columnOptions: columnOptions
    )
    .CreateLogger();

builder.Host.UseSerilog();
</code></pre>
        <p>2.. 小試一下:</p>
        <p>(1) 建立的 table 欄位:</p>
        <pre><code class="language-sql">CREATE TABLE [dbo].[Logs] (
    [Id] [int] IDENTITY(1,1) NOT NULL,
    [Message] [nvarchar](max) NULL,
    [Level] [nvarchar](max) NULL,
    [TimeStamp] [datetime] NULL,
    [Exception] [nvarchar](max) NULL,
    [Properties] [nvarchar](max) NULL,
    [SourceContext] [nvarchar](512) NULL,
    [Title] [nvarchar](50) NULL,
    [Status] [int] NULL,
    [Detail] [nvarchar](512) NULL,
    [Instance] [nvarchar](512) NULL,
    [TraceId] [nvarchar](128) NULL,
    [ControllerName] [nvarchar](256) NULL,
    [ActionName] [nvarchar](256) NULL,
 CONSTRAINT [PK_Logs] PRIMARY KEY CLUSTERED ( [Id] ASC )
); 
GO
</code></pre>
        <p>(2) 執行結果:<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/63-SerilogOutput_Mssql_hardcode_02.png?raw=true" alt="63 SerilogOutput_Mssql_hardcode_02" /></p>
        <p>3.. 不想看到那麼多的日誌記錄, 要怎麼作?
            如果不需要記錄每次的 request / response 之間的執行時間, 可以把 UseSerilogRequestLogging() 這段作 remark, 執行結果截圖如下.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/64-SerilogOutput_Mssql_hardcode_03.png?raw=true" alt="64 SerilogOutput_Mssql_hardcode_03" /></p>
        <p>4.. 如果要對 table:Logs 的 Properties 作查詢, 要如何作?<br />
            Properties 欄位的內容是 Xml 格式, 查詢時要多費一些功夫.</p>
        <p>Properties 資料內容範例:</p>
        <pre><code class="language-xml">&lt;properties&gt;
    &lt;property key='SourceContext'&gt;ASPNETCore8SerilogDemo.Controllers.HomeController&lt;/property&gt;
    &lt;property key='ActionId'&gt;a7b4198c-7254-45a9-9ee8-c3e4b49dcbb9&lt;/property&gt;
    &lt;property key='ActionName'&gt;ASPNETCore8SerilogDemo.Controllers.HomeController.Index (ASPNETCore8SerilogDemo)&lt;/property&gt;
    &lt;property key='RequestId'&gt;0HN2405MHU0LL:00000001&lt;/property&gt;
    &lt;property key='RequestPath'&gt;/&lt;/property&gt;
    &lt;property key='ConnectionId'&gt;0HN2405MHU0LL&lt;/property&gt;
&lt;/properties&gt;
</code></pre>
        <p>SQL 查詢指令:</p>
        <pre><code class="language-sql">SELECT A.*
FROM [Logs] A
WHERE CAST(A.Properties AS xml).value('(/properties/property[@key=&quot;RequestId&quot;]/text())[1]', 'nvarchar(max)') = '0HN2405MHU0LL:00000001';
</code></pre>
        <p>說明:</p>
        <ul>
            <li>/properties: 這個部分表示從 XML 根元素開始. 在 XML 結構中, 根元素是 &lt;properties&gt;.</li>
            <li>/property: 這代表在 &lt;properties&gt; 元素內部進一步巡覽至每個 &lt;property&gt; 子元素.</li>
            <li>[@key=&quot;RequestId&quot;]: 這是一個條件表達式, 用於篩選具有特定屬性值的元素. 在這個例子中, 它過滿足條件 @key=&quot;RequestId&quot; 的 &lt;property&gt; 元素, 即其 key 屬性的值為 &quot;RequestId&quot;.<br />
                註: Refers to finding XML elements by name and attributes.</li>
            <li>/text(): 這個函數用來選擇符合上述條件的元素的資料內容.<br />
                註: Refers to accessing the actual textual content within those selected elements.</li>
            <li>[1]：因為 XPath 表達式可能返回一個節點的集合. 即使你只期望一個結果. 這個 [1] 是一個索引, 用來從可能的節點集中選取第一個節點.</li>
        </ul>
        <h3 id="六-改用自定義的統一輸出格式-myproblemdetails-">(六) 改用自定義的統一輸出格式 (MyProblemDetails) <a id="section7_6"></a></h3>
        <p>由於 System.Text.Json 及 Newtonsoft.Json 對於 ProblemDetails 的 Extensions 欄位有不同的序列化方式; 前者會打平, 後者會將在 Extensions 增加的欄位, 多加一層 Extensions 的節點. 故建立一個繼承自 ProblemDetails 的類別, 把增加的欄位, 全部打平, 後續前端在作處理時, 會方便許多.</p>
        <pre><code class="language-csharp">public class MyProblemDetails : ProblemDetails
{
    /// &lt;summary&gt;
    /// Http Request 的追蹤代號 (GUID)
    /// &lt;/summary&gt;
    public string? TraceId { get; set; } = string.Empty;

    /// &lt;summary&gt;
    /// Controller 全名
    /// &lt;/summary&gt;
    public string? ControllerName { get; set; }  = string.Empty;

    /// &lt;summary&gt;
    /// Action 名稱
    /// &lt;/summary&gt;
    public string? ActionName { get; set; } = string.Empty;

    /// &lt;summary&gt;
    /// 使用者代碼
    /// &lt;/summary&gt;
    public string? UserId { get; set; } = string.Empty;
}
</code></pre>
        <h3 id="七-建立一層-loggingservicet-打包-iloggert-以利寫入資料庫欄位-">(七) 建立一層 LoggingService&lt;T&gt; 打包 ILogger&lt;T&gt;, 以利寫入資料庫欄位 <a id="section7_7"></a></h3>
        <p>各位如果有細看先前資料庫輸出的內容, 可以發現有些 Log 記錄沒有寫入 table:Logs 的 TraceId, ControllerName, ActionName, Instance 欄位. 這是因為沒有用 {@placeHolder} 的方式去定義輸出欄位, 所以對應不上, 例如:</p>
        <pre><code class="language-csharp">_logger.LogInformation(&quot;ASPNETCore8SerilogDemo首頁&quot;);
</code></pre>
        <p>因此, 筆者定義了一層 LoggingService&lt;T&gt; 將 Microsoft.Extensions.Logging.LoggerExtensions 靜態類別 的 LogInformation, LogWarning, LogError 等方法, 重新包裝一層, 主動補上 MyProblemDetails 的欄位內容, 這樣上述 table:Logs 的欄位, 就會有資料內容了.</p>
        <p>有興趣的朋友, 可自行參考程式內容.</p>
        <p>另外, <strong>關於 @ 解構子的作用, 可以看一下 &quot;產品清單&quot; 那個功能的 Console 輸出.</strong></p>
        <p>1.. 採用 _logger.LogInformation().</p>
        <pre><code class="language-csharp">_logger.LogInformation(&quot;產品清單(_logger): {myId} {products}&quot;, &quot;001&quot;, products);
_logger.LogInformation(&quot;產品清單(_logger): {@myId} {@products}&quot;, &quot;002&quot;, products);
</code></pre>
        <p>(1) 不加 @ 解構子: 只會出現 ProductViewModel 這個 class name</p>
        <pre><code class="language-ini">2024-03-16 20:24:46.452 [INF] 產品清單(_logger): 001 [&quot;ASPNETCore8SerilogDemo.Models.ProductViewModel&quot;, &quot;ASPNETCore8SerilogDemo.Models.ProductViewModel&quot;]
</code></pre>
        <p>(2) 有加 @ 解構子: 除了出現 ProductViewModel 這個 class name 之外, 還包括其內容.</p>
        <pre><code class="language-ini">2024-03-16 20:24:46.459 [INF] 產品清單(_logger): 002 [ProductViewModel {Id=1, Name=&quot;布丁&quot;, OrderQty=1, UnitPrice=50}, ProductViewModel {Id=2, Name=&quot;蛋塔&quot;, OrderQty=1, UnitPrice=40}]
</code></pre>
        <p>2.. 採用 _loggingService.LogInformation().</p>
        <pre><code class="language-csharp">_loggingService.LogInformation(&quot;產品清單(_loggingService): {products}&quot;, products);
_loggingService.LogInformation(&quot;產品清單(_loggingService): {@products}&quot;, products);
</code></pre>
        <p>(1) 不加 @ 解構子: 因為 LoggingService, 會主動改成 {@structuredData} 作為解構子, 除了出現 ProductViewModel 這個 class name 之外, 還包括其內容.</p>
        <pre><code class="language-ini">2024-03-16 20:24:46.474 [INF] 產品清單(_loggingService): {products}: [ProductViewModel {Id=1, Name=&quot;布丁&quot;, OrderQty=1, UnitPrice=50}, ProductViewModel {Id=2, Name=&quot;蛋塔&quot;, OrderQty=1, UnitPrice=40}]: MyProblemDetails {TraceId=&quot;a6184631-8818-41f7-beda-d959559dce37&quot;, ControllerName=&quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;, ActionName=&quot;Index&quot;, UserId=&quot;jasper&quot;, Type=null, Title=&quot;OK&quot;, Status=200, Detail=&quot;&quot;, Instance=&quot;/Product&quot;, Extensions={}}
</code></pre>
        <p>(2) 有加 @ 解構子: 除了出現 ProductViewModel 這個 class name 之外, 還包括其內容.</p>
        <pre><code class="language-ini">2024-03-16 20:24:46.491 [INF] 產品清單(_loggingService): {@products}: [ProductViewModel {Id=1, Name=&quot;布丁&quot;, OrderQty=1, UnitPrice=50}, ProductViewModel {Id=2, Name=&quot;蛋塔&quot;, OrderQty=1, UnitPrice=40}]: MyProblemDetails {TraceId=&quot;a6184631-8818-41f7-beda-d959559dce37&quot;, ControllerName=&quot;ASPNETCore8SerilogDemo.Controllers.ProductController&quot;, ActionName=&quot;Index&quot;, UserId=&quot;jasper&quot;, Type=null, Title=&quot;OK&quot;, Status=200, Detail=&quot;&quot;, Instance=&quot;/Product&quot;, Extensions={}}
</code></pre>
        <p>(3) 前述 2 者幾乎沒什麼差異, 但在 Seq 可以看得更清楚.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/71-SerilogOutput_Mssql_in_seq.png?raw=true" alt="71 SerilogOutput_Mssql_in_seq" /><br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/72-SerilogOutput_Mssql_in_seq.png?raw=true" alt="72 SerilogOutput_Mssql_in_seq" /></p>
        <p>3.. 附上資料庫輸出的截圖.<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/73-SerilogOutput_Mssql_in_ssms.png?raw=true" alt="73 SerilogOutput_Mssql_in_ssms" /><br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/74-SerilogOutput_Mssql_in_ssms.png?raw=true" alt="74 SerilogOutput_Mssql_in_ssms" /></p>
        <h2 id="八-關於-serilog-的增強器-enrichers-">八. 關於 Serilog 的增強器 (Enrichers) <a id="section8"></a></h2>
        <h3 id="一-簡介">(一) 簡介</h3>
        <p>Serilog 的增強功能允許在整個應用程序中系統地向Log記錄添加額外信息. 這些額外信息可以是任何有助於提供更多上下文的信息, 如應用程式版本、環境名稱或使用者代號.<br />
            可<a href="https://github.com/serilog/serilog/wiki/Enrichment" target="_blank">參考官網說明</a>, 以下僅列出幾個現成的增強器.</p>
        <ul>
            <li><a href="https://github.com/serilog/serilog-enrichers-environment" target="_blank">Serilog.Enrichers.Environment</a>: WithMachineName() and WithEnvironmentUserName()
                <ul>
                    <li>安裝以下套件: Serilog.Enrichers.Environment</li>
                </ul>
            </li>
            <li><a href="https://github.com/serilog/serilog-enrichers-process" target="_blank">Serilog.Enrichers.Process</a>: WithProcessId()
                <ul>
                    <li>安裝以下套件: Serilog.Enrichers.Process</li>
                </ul>
            </li>
            <li><a href="https://github.com/serilog/serilog-enrichers-thread" target="_blank">Serilog.Enrichers.Thread</a>: WithThreadId()
                <ul>
                    <li>安裝以下套件: Serilog.Enrichers.Thread</li>
                </ul>
            </li>
        </ul>
        <h3 id="二-使用內建的-enricher">(二) 使用內建的 Enricher</h3>
        <p>1.. 修改 Program.cs.<br />
            (1) 加入 Enrich.WithXXXX()</p>
        <pre><code class="language-csharp">Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .MinimumLevel.Override(&quot;Microsoft.AspNetCore&quot;, LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()    // Adds the machine name
    .Enrich.WithThreadId()       // Adds the thread id
    .Enrich.WithEnvironmentName() // Adds the environment name (e.g., Development, Product
    .Enrich.WithProperty(&quot;Application&quot;, &quot;SerilogEnricherDemo&quot;) // 加入自定義的屬性, 這個是全域的; 如果是用 PushProperty 的話, 則只限於某個 using 的區塊或整個 method
    .WriteTo.Console(
        outputTemplate: &quot;{Timestamp:yyyy-MM-dd HH:mm:ss} [{Level:u3}] {Message:l} {Properties}{NewLine}{Exception}&quot;
    )
    .WriteTo.File(&quot;logs/log-.txt&quot;, rollingInterval: RollingInterval.Day)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;)
    .CreateLogger();

// 使用 Serilog
builder.Host.UseSerilog();
</code></pre>
        <p>2.. 小試一下.<br />
            檢查 Console 的輸出, 可以看到每一筆 Log 記錄, 都有 MachineName=&quot;MyComputer01&quot;, ThreadId=1, EnvironmentName=&quot;Development&quot;, Application=&quot;SerilogEnricherDemo&quot;.</p>
        <pre><code class="language-ini">2024-03-19 17:07:48 [INF] Processed {Latitude=25, Longitude=134} in 34 ms {SourceContext=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController&quot;, ActionId=&quot;039ad7da-4fa8-495e-ba8c-6213bd744d16&quot;, ActionName=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController.Index (ASPNETCore8SerilogEnrich)&quot;, RequestId=&quot;0HN27UG63SI37:00000001&quot;, RequestPath=&quot;/&quot;, ConnectionId=&quot;0HN27UG63SI37&quot;, MachineName=&quot;MyComputer01&quot;, ThreadId=14, EnvironmentName=&quot;Development&quot;, Application=&quot;SerilogEnricherDemo&quot;}
</code></pre>
        <h3 id="三-建立自定義的-enrichers">(三) 建立自定義的 Enrichers.</h3>
        <p>前面所述是內建或別人寫的 Enrichers, 要如何自己寫一個呢?</p>
        <p>1.. 建立一個實作 ILogEventEnricher 的類別.</p>
        <pre><code class="language-csharp">public class ReleaseNumberEnricher : ILogEventEnricher
{
    LogEventProperty _cachedProperty = null!;
    public const string PropertyName = &quot;ReleaseNumber&quot;;

    /// &lt;summary&gt;
    /// Enrich the log event.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;logEvent&quot;&gt;The log event to enrich.&lt;/param&gt;
    /// &lt;param name=&quot;propertyFactory&quot;&gt;Factory for creating new properties to add to the event.&lt;/param&gt;
    public void Enrich(LogEvent logEvent, ILogEventPropertyFactory propertyFactory)
    {
        logEvent.AddPropertyIfAbsent(GetLogEventProperty(propertyFactory));
    }

    private LogEventProperty GetLogEventProperty(ILogEventPropertyFactory propertyFactory)
    {
        // Don't care about thread-safety, in the worst case the field gets overwritten and one property will be GCed
        if (_cachedProperty == null)
            _cachedProperty = CreateProperty(propertyFactory);

        return _cachedProperty;
    }
    
    private static LogEventProperty CreateProperty(ILogEventPropertyFactory propertyFactory)
    {
        var value = Environment.GetEnvironmentVariable(&quot;RELEASE_NUMBER&quot;) ?? &quot;local&quot;;
        return propertyFactory.CreateProperty(PropertyName, value);
    }
}
</code></pre>
        <p>2.. 建立一個擴充方法, 供 Program.cs 裡的 Enrich 叫用.</p>
        <pre><code class="language-csharp">public static class LoggingExtensions
{
    public static LoggerConfiguration WithReleaseNumber(
        this LoggerEnrichmentConfiguration enrich)
    {
        ArgumentNullException.ThrowIfNull(enrich);
        return enrich.With&lt;ReleaseNumberEnricher&gt;();
    }
}
</code></pre>
        <p>3.. 修改 Program.cs.<br />
            (1) 設定環境變數 RELEASE_NUMBER.</p>
        <pre><code class="language-csharp">#region 設定環境變數 RELEASE_NUMBER, 供 WithReleaseNumber Enricher 使用.
Environment.SetEnvironmentVariable(&quot;RELEASE_NUMBER&quot;, &quot;1.0.0&quot;);
#endregion
</code></pre>
        <p>(2) 加入 .Enrich.WithReleaseNumber()</p>
        <pre><code class="language-csharp">Log.Logger = new LoggerConfiguration()
    .MinimumLevel.Information()
    .MinimumLevel.Override(&quot;Microsoft.AspNetCore&quot;, LogEventLevel.Warning)
    .Enrich.FromLogContext()
    .Enrich.WithMachineName()    // Adds the machine name
    .Enrich.WithThreadId()       // Adds the thread id
    .Enrich.WithEnvironmentName() // Adds the environment name (e.g., Development, Product
    // 加入自定義的屬性, 這個是全域的; 如果是用 PushProperty 的話, 則只限於某個 using 的區塊或整個 method
    .Enrich.WithProperty(&quot;Application&quot;, &quot;SerilogEnricherDemo&quot;)
    .Enrich.WithReleaseNumber()
    .WriteTo.Console(
        outputTemplate: &quot;{Timestamp:yyyy-MM-dd HH:mm:ss} [{Level:u3}] {Message:l} {Properties}{NewLine}{Exception}&quot;
    )
    .WriteTo.File(&quot;logs/log-.txt&quot;, rollingInterval: RollingInterval.Day)
    .WriteTo.Seq(&quot;http://localhost:5341&quot;)
    .CreateLogger();

// 使用 Serilog
builder.Host.UseSerilog();
</code></pre>
        <p>4.. 小試一下.
            在 Console 上呈現的結果大致如下.</p>
        <pre><code class="language-ini">2024-03-19 17:18:27 [INF] Web Application 設置完成, 即將啟動... {MachineName=&quot;MyComputer01&quot;, ThreadId=1, EnvironmentName=&quot;Development&quot;, Application=&quot;SerilogEnricherDemo&quot;, ReleaseNumber=&quot;1.0.0&quot;}
2024-03-19 17:18:27 [INF] 這是 Enrich 首頁 {SourceContext=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController&quot;, ActionId=&quot;5e8bc332-aa05-4d3c-ba3d-680d1db6884e&quot;, ActionName=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController.Index (ASPNETCore8SerilogEnrich)&quot;, RequestId=&quot;0HN27UM4M1L1P:00000001&quot;, RequestPath=&quot;/&quot;, ConnectionId=&quot;0HN27UM4M1L1P&quot;, MachineName=&quot;MyComputer01&quot;, ThreadId=9, EnvironmentName=&quot;Development&quot;, Application=&quot;SerilogEnricherDemo&quot;, ReleaseNumber=&quot;1.0.0&quot;}
2024-03-19 17:18:27 [INF] Processed {Latitude=25, Longitude=134} in 34 ms {SourceContext=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController&quot;, ActionId=&quot;5e8bc332-aa05-4d3c-ba3d-680d1db6884e&quot;, ActionName=&quot;ASPNETCore8SerilogEnrich.Controllers.HomeController.Index (ASPNETCore8SerilogEnrich)&quot;, RequestId=&quot;0HN27UM4M1L1P:00000001&quot;, RequestPath=&quot;/&quot;, ConnectionId=&quot;0HN27UM4M1L1P&quot;, MachineName=&quot;MyComputer01&quot;, ThreadId=9, EnvironmentName=&quot;Development&quot;, Application=&quot;SerilogEnricherDemo&quot;, ReleaseNumber=&quot;1.0.0&quot;}
</code></pre>
        <h2 id="結論">結論</h2>
        <p>又是一篇花不少時間及心力的文章, 整個脈絡如下圖:<br />
            <img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/91-Summary.png?raw=true" alt="Summary" /></p>
        <p><strong>最大的瓶頸在於輸出至 Mssql 資料庫</strong>, 如果不需將 Log 記錄內容獨立為欄位, 其實只需預設建立的欄位即可 ([Id], [Message], [Level], [TimeStamp], [Exception], [Properties]). 只是 [Message] 及 [Properties] 欄位不容易以 SQL 查詢.</p>
        <p>如果公司同意用 Seq 的話, 那是最方便不過的:<br />
            (1) 開發人員不用去想資料庫的 table 要放那些欄位.<br />
            (2) 開發人員不用去開發查詢 UI.<br />
            (3) 系統管理人員有現成方便 UI, 而且有方便的過濾條件可以使用.</p>
        <p>原本想要試一下寫到 Oracle, 但發現 <a href="https://www.nuget.org/packages/Serilog.Sinks.Oracle" target="_blank">Serilog.Sinks.Oracle</a> 最近的更新日期在 2020.04.24, 且沒有被列在 <a href="https://github.com/serilog/serilog/wiki/Provided-Sinks" target="_blank">Provided Sinks for Serilog</a> 清單裡, 看來要花更多時間去實證, 後續有空再試看看.</p>
        <h2 id="參考文件">參考文件</h2>
        <ul>
            <li>
                <p><a href="https://blog.miniasp.com/post/2021/11/29/How-to-use-Serilog-with-NET-6" target="_blank">1.. (Will 保哥) .NET 6.0 如何使用 Serilog 對應用程式事件進行結構化紀錄</a></p>
            </li>
            <li>
                <p><a href="https://dotblogs.azurewebsites.net/yc421206/2022/09/04/serilog_config_in_asp_net_core" target="_blank">2.. (余小章) .NET 6 應用程式如何設定 Serilog</a></p>
            </li>
        </ul>
        <blockquote>
            <p>(1) 透過 docker 執行 seq 的指令: <strong>docker run --name seq -d --restart unless-stopped -e ACCEPT_EULA=Y -p 5341:80 datalust/seq:latest</strong><br />
                (2) 在瀏覽器網址列輸入: <strong><a href="http://localhost:5341/" target="_blank">http://localhost:5341/</a></strong> 就可以進入 seq 的 Web UI 介面.</p>
        </blockquote>
        <ul>
            <li>
                <p><a href="https://medium.com/appxtech/%E5%BE%9E0%E5%88%B01%E7%9A%84%E5%BB%BA%E7%AB%8Bweb-api%E5%B0%88%E6%A1%88-serilog-%E6%90%AD%E9%85%8D-seq-%E7%B4%80%E9%8C%84log-4662bfce1d8a" target="_blank">3.. (Medium)(Sharon) ｜從0到1的建立Web API專案｜ Serilog 搭配 Seq 紀錄Log</a></p>
            </li>
            <li>
                <p><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-8.0" target="_blank">4.. (Microsoft Learn) Logging in .NET Core and ASP.NET Core</a></p>
            </li>
            <li>
                <p><a href="https://github.com/serilog/serilog/wiki/Provided-Sinks" target="_blank">5.. Provided Sinks for Serilog</a></p>
            </li>
        </ul>
        <blockquote>
            <p>(GitHub) Serilog 可用的記錄目標 (Log Sinks) 清單.</p>
        </blockquote>
        <ul>
            <li><a href="https://github.com/serilog/serilog-aspnetcore#request-logging" target="_blank">6.. Serilog.AspNetCore Request Logging (UseSerilogRequestLogging middleware)</a></li>
        </ul>
        <blockquote>
            <p>(GitHub) UseSerilogRequestLogging middleware 的使用說明.</p>
        </blockquote>
        <ul>
            <li><a href="https://datalust.co/seq" target="_blank">7.. Seq 官網</a></li>
        </ul>
        <blockquote>
            <p>訂閱方式總共有 4 個層級: Individual / Team / Enterprise / Datacenter. Individual 是免費的.<br />
                下圖所謂的使用者數, 係指 Web UI 可以登入的 User Id, 在 Individual 的狀況下, 預設是 admin.<br />
                The Individual license permits one person to access the Seq web interface. Seq installations configured with the <strong>Individual license can't be accessed by more than one person, regardless of whether or not login credentials are shared</strong>. If more than one person will use a Seq instance, a multi-user subscription is required.</p>
        </blockquote>
        <p><img src="https://github.com/jasper-lai/20240323_ASPNETCore8SerilogDemo/blob/master/pictures/A-1_Seq_Service_Pricing.png?raw=true" alt="A 1_Seq_Service_Pricing" /></p>
        <ul>
            <li>
                <p><a href="https://github.com/datalust" target="_blank">8.. (GitHub) Datalust (提供 Seq 系列產品的公司) 的 Open Source Repositories</a></p>
            </li>
            <li>
                <p><a href="https://marcus116.blogspot.com/2019/05/netcore-serilog-events-types-enrichers.html" target="_blank">9.. [NETCore] 結構化日誌 Serilog - Events Types 和 Enrichment</a></p>
            </li>
            <li>
                <p><a href="https://www.ctrlaltdan.com/2018/08/14/custom-serilog-enrichers/" target="_blank">10.. Creating custom serilog enrichers</a></p>
            </li>
            <li>
                <p><a href="https://docs.datalust.co/docs/data-store" target="_blank">11.. (Seq) Data Store</a></p>
            </li>
        </ul>
        <blockquote>
            <p><strong>The Metastore</strong>: contains configuration data such as users, signals, dashboards, and so on. Native (embedded storage in the <strong>Documents/</strong> subfolder under Seq's local storage root). This is the default option for Seq installs and doesn't rely on any external database or storage technologies.<br />
                <strong>The Event Store</strong>: contains the application log data that is searchable in the Seq UI. The event store persists data in the <strong>Stream/</strong> directory under Seq's local storage root.</p>
        </blockquote>
        <p>筆者補充(2024.03.25): <strong>如何進入 container 查看相關的資料夾及檔案結構?</strong></p>
        <pre><code class="language-powershell">PS D:\Temp&gt; docker exec -it seq bash 
</code></pre>
        <pre><code class="language-bash"># cd /data
# ls -al
total 32
drwxr-xr-x 7 root root 4096 Mar 25 03:03 .
drwxr-xr-x 1 root root 4096 Mar 11 06:34 ..
drwxr-xr-x 2 root root 4096 Mar 25 03:03 Backups
drwxr-xr-x 2 root root 4096 Mar 25 02:23 Documents
drwxr-xr-x 2 root root 4096 Mar 11 06:34 Init
drwxr-xr-x 2 root root 4096 Mar 25 02:23 Logs
-rw-r--r-- 1 root root 2186 Mar 25 02:23 Seq.json
drwxr-xr-x 2 root root 4096 Mar 25 02:43 Stream
# ls -al Backups
total 20
drwxr-xr-x 2 root root 4096 Mar 25 03:03 .
drwxr-xr-x 7 root root 4096 Mar 25 03:03 ..
-rw-r--r-- 1 root root 9344 Mar 25 03:03 seq_20240325.seqbac
# ls -al Logs
total 568
drwxr-xr-x 2 root root   4096 Mar 25 02:23 .
drwxr-xr-x 7 root root   4096 Mar 25 03:03 ..
-rw-r--r-- 1 root root  81969 Mar 11 09:11 seq-20240311.log
-rw-r--r-- 1 root root  64982 Mar 12 09:06 seq-20240312.log
-rw-r--r-- 1 root root  33544 Mar 14 09:16 seq-20240314.log
-rw-r--r-- 1 root root  50795 Mar 15 09:13 seq-20240315.log
-rw-r--r-- 1 root root  80574 Mar 16 13:39 seq-20240316.log
-rw-r--r-- 1 root root   6943 Mar 17 02:53 seq-20240317.log
-rw-r--r-- 1 root root 189137 Mar 19 09:26 seq-20240319.log
-rw-r--r-- 1 root root  19531 Mar 25 03:08 seq-20240325.log

# ls -al Documents
total 100
drwxr-xr-x 2 root root  4096 Mar 25 02:23 .
drwxr-xr-x 7 root root  4096 Mar 25 03:03 ..
-rw-r--r-- 1 root root   782 Mar 25 02:23 metastore.2.metadata
-rw-r--r-- 1 root root     8 Mar 11 06:34 metastore.collection.561b552d29b849fea3a926001b28d507.docc
-rw-r--r-- 1 root root 80322 Mar 25 02:36 metastore.collection.c4f86f07cff148209386011ea284a0d7.docc
-rw-r--r-- 1 root root     8 Mar 11 06:34 metastore.flare

# ls -al Stream
total 128
drwxr-xr-x 2 root root  4096 Mar 25 02:43 .
drwxr-xr-x 7 root root  4096 Mar 25 03:03 ..
-rw-r--r-- 1 root root   543 Mar 25 02:43 stream.08dc458cd7eae000_08dc47e7ebde4e00.ed3041b2faf247ada4dbd6f08c3d4fcb.index
-rw-r--r-- 1 root root 47171 Mar 25 02:33 stream.08dc458cd7eae000_08dc47e7ebde4e00.fb8790661cbd4816b852841a57a5d44c.span
-rw-r--r-- 1 root root   277 Mar 25 02:43 stream.08dc47ee7cb82800_08dc47f58abd7700.4a3d1e88929549c3a30806512520285a.index
-rw-r--r-- 1 root root 26239 Mar 25 02:33 stream.08dc47ee7cb82800_08dc47f58abd7700.6c237a69c55a4ea0b5beea53449303d4.span
-rw-r--r-- 1 root root  5140 Mar 25 02:30 stream.08dc4c73781ec400.899cf442a7f442c18f6c9ffdea4f28d9.tick
-rw-r--r-- 1 root root  1624 Mar 25 02:34 stream.08dc4c74072bdc00.aeb40580f55c433b93f01dc6afd35514.tick
-rw-r--r-- 1 root root  2377 Mar 25 02:35 stream.08dc4c743cd0c500.73c8fbd959b34f85b49980b7bed388bb.tick
-rw-r--r-- 1 root root  8538 Mar 25 02:43 stream.2.metadata
-rw-r--r-- 1 root root   973 Mar 11 06:44 stream.collection.d4b3bf22938947b3862d2b4f8b44c6ae.docc
-rw-r--r-- 1 root root     8 Mar 11 06:34 stream.flare
</code></pre>
    </div>
</body>